---
title: Create a Turing machine visualizer with XState and Vue
description: In this article I share XState patterns that I used to create a visualizer for Turing machines with XState and Vue.
datetime: 2022-07-31T11:56:59.393Z
tags: ['XState', 'Vue']
---

**Add description of the project and link to online website**

**Say that we use Vue 3 with Composition API, and XState with TypeScript (schema to define context and events)**

## Move tape automatically

When the user clicks to play the machine, the tape starts to move automatically, one step per second. The speed can be increased to reach two steps per second.

![Tape moves automatically and speed is increased](/img/turing/automatic-playing-with-different-speed-modes.gif)

By default, automatic playing is off. User needs to click the play button to start automatic playing:

```ts
import { createMachine } from "xstate";

const vizMachine = createMachine({
    // ...
    schema: {
        events: {} as
            | { type: "Play" },
    },
    initial: "Automatic playing off",
    states: {
        "Automatic playing off": {
            on: {
                Play: {
                    target: "Automatic playing on",
                },
            },
        },
        "Automatic playing on": {},
    },
    // ...
});
```

To make automatic playing work, we create a delayed transition in `Automatic playing on` state, that transitions to the state itself, after incrementing the index of the step:

```ts {1-9, 20-29, 33-37}
const vizMachine = createMachine({
    context: {
        stepsIndex: 0,
    },
    schema: {
        context: {} as {
            stepsIndex: number;
        },
        // ...
    },
    // ...
    initial: "Automatic playing off",
    states: {
        "Automatic playing off": {
            on: {
                Play: {
                    target: "Automatic playing on",
                },
            },
        },
        "Automatic playing on": {
            after: {
                "automatic playing delay": {
                    actions: "Increment step index",
                    target: "Automatic playing on",
                    // Make the transition external to recreate the delay.
                    internal: false,
                },
            },
        },
    },
    // ...
}, {
    actions: {
        "Increment step index": assign({
            stepIndex: (context) => context.stepIndex + 1,
        }),
    },
});
```

Note that the transition is explicitly made external through `internal: false`. This is necessary because `Automatic playing on` state needs to be reentered for the delayed transition to be set up again.

The delay transition is defined with a string, which references a function dynamically computing the delay. It uses the speed mode, stored in context, to determine the delay between two steps:

```ts {1-16, 33-37, 40-44, 49-51}
const vizMachine = createMachine({
    context: {
        stepsIndex: 0,
        automaticPlayingDelayMode: "MEDIUM",
    },
    schema: {
        context: {} as {
            stepsIndex: number;
            automaticPlayingDelayMode: "MEDIUM" | "FAST";
        },
        events: {} as 
            | { type: "..." } // Other events...
            | {
                type: "Set automatic playing delay";
                mode: "MEDIUM" | "FAST";
            },
    },
    // ...
    initial: "Automatic playing off",
    states: {
        "Automatic playing off": {
            // ...
        },
        "Automatic playing on": {
            after: {
                "automatic playing delay": {
                    actions: "Increment step index",
                    target: "Automatic playing on",
                    internal: false,
                },
            },
        },
    },
    on: {
        "Set automatic playing delay": {
            actions: "Assign automatic playing delay to context",
        },
    },
    // ...
}, {
    delays: {
        "automatic playing delay": (context) => {
            return context.automaticPlayingDelayMode === "MEDIUM" ? 1000 : 500
        },
    },
    actions: {
        "Increment step index": assign({
            stepIndex: (context) => context.stepIndex + 1,
        }),
        "Assign automatic playing delay to context": assign({
            automaticPlayingDelayMode: (_, event) => event.mode,
        }),
    },
});
```

If the speed mode is modified while a timer is pending, only the timer of the next tick will know about the change. The current timer is **not** reset.

On Vue side, we compute the squares to print on the tape according to the step list and the current step index, and we let `<TransitionGroup />` handle the smooth transition of squares:

```svelte
<TransitionGroup
    move-class="transition-all duration-200"
>
    <div
        v-for="{ key, value } in displayedTape"
        :id="key"
        :key="key"
    >
        <!-- ... -->
    </div>
</TransitionGroup>
```

## Pause and resume automatic playing

![Player is paused and resumed](/img/turing/pause-and-play.gif)

Player can be stopped and resumed with a single state transition:

```ts
const vizMachine = createMachine({
    // ...
    schema: {
        // ...
        events: {} as
            | { type: "..." } // Other events...
            | { type: "Pause" },
    },
    initial: "Automatic playing off",
    states: {
        "Automatic playing off": {
            on: {
                Play: {
                    target: "Automatic playing on",
                },
            },
        },
        "Automatic playing on": {
            after: {
                "automatic playing delay": { /** */ },
            },
            on: {
                Pause: {
                    target: "Automatic playing off",
                },
            },
        },
    },
    // ...
});
```

When we exit `Automatic playing on` state, the delay transition is cancelled. When we come back to `Automatic playing on` state, the delay transition is set up again, and some milliseconds later the tape will have been moved.

## Move tape step by step

When debugging a Turing machine, one would want to analyze what occurs precisely on the tape. In this case, the automatic playing mode would not be really suitable. Instead, the user can move the tape step by step.

![Player is played, then manual mode is entered to execute step by step](/img/turing/manual-step-by-step.gif)

When we receive `Next step` event, that is emitted by next step button, we target `Automatic playing off` state from its parent node. Whether the automatic playing was on or not, we turn it off. We reuse the action that increments the step index and execute it each time the button is clicked:

```ts
const vizMachine = createMachine({
    // ...
    schema: {
        // ...
        events: {} as
            | { type: "..." } // Other events...
            | { type: "Next step" },
    },
    initial: "Automatic playing off",
    states: {
        "Automatic playing off": { /** */ },
        "Automatic playing on": { /** */ },
    },
    on: {
        "Next step": {
            actions: "Increment step index",
            target: ".Automatic playing off",
        },
    },
    // ...
});
```

Again, because `Automatic playing on` state is exited, if a timer was scheduled, it is cancelled.

## Know when end of steps is reached

When end of steps is reached, we want to tell it to the user, stop automatic playing and allow restarting steps.

![End of steps is reached and steps are restarted from beginning](/img/turing/reaching-end-of-steps.gif)

To implement this behavior, we need to wrap `Automatic playing off` and `Automatic playing on` states in another state, we name `Playing steps`. This state has a sibling state called `Reached end of steps` we want to target when end of steps has been reached:

```ts
const vizMachine = createMachine({
    // ...
    initial: "Playing steps",
    states: {
        "Playing steps": {
            // States defined previously
            initial: "Automatic playing off",
            states: {
                "Automatic playing off": { /** */ },
                "Automatic playing on": { /** */ },
            },
            on: {
                "Next step": { /** */ },
            },
        },
        "Reached end of steps": {},
    },
    // ...
});
```

We use an [eventless transition](https://xstate.js.org/docs/guides/transitions.html#eventless-always-transitions) (with `always` keyword) to target `Reached end of steps` state when `Has reached end of steps` condition is met:

```ts {10-13, 23-30}
const vizMachine = createMachine({
    // ...
    initial: "Playing steps",
    states: {
        "Playing steps": {
            initial: "Automatic playing off",
            states: {
                "Automatic playing off": { /** */ },
                "Automatic playing on": { /** */ },
            },
            always: {
                cond: "Has reached end of steps",
                target: "Reached end of steps",
            },
            on: {
                "Next step": { /** */ },
            },
        },
        "Reached end of steps": {},
    },
    // ...
}, {
    guards: {
        /**
         * The guard must return true after index
         * has been incremented one extraneous time.
         * There is no step at index `context.stepIndex`.
         */
        "Has reached end of steps": (context) => {
            return context.stepIndex >= STEPS_LENGTH;
        },
    },
});
```

Say that automatic playing is turned on, and the current step is the last one, the timer of automatic playing is about to end. The behavior of the machine is:

1. Delay is reached
1. Step index is incremented
1. Reenter `Automatic playing on` state
2. Compute `Has reached end of steps` condition; as it returns `true`, target `Reached end of steps` state
3. Enter `Reached end of steps` state

`Reached end of steps` state is entered even before the timer of `Automatic playing on` state is restarted.

The eventless transition will be tried when the state in which it is defined is entered for the first time, and then every time the machine processes an event.

### Restart steps when end has been reached

To enable to restart steps, we listen to another event in `Reached end of steps`:

```ts {2-7, 13-20, 25-27}
const vizMachine = createMachine({
    // ...
    schema: {
        // ...
        events: {} as
            | { type: "..." } // Other events...
            | { type: "Reset steps" },
    },
    initial: "Playing steps",
    states: {
        "Playing steps": {
            // ...
        },
        "Reached end of steps": {
            on: {
                "Reset steps": {
                    actions: "Reset step index",
                    target: "Playing steps",
                },
            },
        },
    },
    // ...
}, {
    actions: {
        "Reset step index": assign({
            stepIndex: (_context) => 0,
        }),
    },
});
```

When this transition is taken, the tape recovers its original state, and all that remains is for the user to click on play button.

## Synchronize input and machine configuration values with machine

We want the machine to always hold the most recent values of the input and machine configuration.

```ts
const vizMachine = createMachine({
    // ...
    context: {
        // Other properties...
        input: "",
        machineCode: "",
    },
    schema: {
        context: {} as {
            // Other properties...
            input: string;
            machineCode: string;
        },
        events: {} as
            | { type: "..." } // Other events...
            | { type: "Set input"; input: string }
            | { type: "Set machine code"; machineCode: string },
    },
    // ...
    on: {
        "Set input": {
            actions: "Assign input to context",
        },
        "Set machine code": {
            actions: "Assign machine code to context",
        },
    },
    // ...
}, {
    actions: {
        "Assign input to context": assign({
            input: (_, event) => event.input,
        }),
        "Assign machine code to context": assign({
            machineCode: (_, event) => event.machineCode,
        }),
    },
});
```

On Vue side, the value of inputs must reflect the values in the context, and when inputs get changed, they send events to the machine:

```svelte
<input
    :value="state.context.input"
    @input="send({
        type: "Set input",
        input: $event.target.value,
    })"
/>
```

## Send input and machine configuration to server for execution

![Execution succeeds and visualizer is usable](/img/turing/loading-successful.gif)

We wrote a server in Erlang to compute Turing machines. It expects the input and the machine configuration to be sent as JSON in a POST request.

A first implementation can be to create a state sibling to `Playing steps` for instance, and wait for a `Load` event to make the request:

```ts
const vizMachine = createMachine({
    // ...
    initial: "Playing steps",
    states: {
        "Playing steps": {
            on: {
                Load: {
                    target: "Making request to server",
                }
            }
        },
        "Making request to server": {
            invoke: {
                src: "Execute machine and input on server",
                onDone: {
                    actions: "Assign machine execution to context",
                },
                // ...
            },
        },
    },
    // ...
});
```

In this implementation, `Playing steps` and `Making request to server` states are mutually exclusive, that is that they can not be active at the same time. When making a request to the server to compute a new execution, current Turing machine can not be visualized anymore. This may be the behavior you want to implement, and indeed this is what we wanted. But things get harder when we want to deal with error cases.

![Execution failed server-side, but visualizer can still be used with previous execution](/img/turing/loading-unsuccessful.gif)

If execution fails, we want to display an alert telling the user that an error occurred and that the visualizer does not show the latest execution, but the last one that succeeded. We need to store in the machine, somewhere, the state of the last execution that failed.

We can target an error state when execution fails, and after use `state.matches()` to test whether this state is active:

```ts {9-11, 14}
const vizMachine = createMachine({
    // ...
    initial: "Playing steps",
    states: {
        "Playing steps": { /** */ },
        "Making request to server": {
            invoke: {
                src: "Execute machine and input on server",
                // ...
                onError: {
                    target: "Failed to execute machine with input",
                },
            },
        },
        "Failed to execute machine with input": { /** */ },
    },
    // ...
});
```

But now, if an error occurred during the last execution, we can no longer interact with the visualizer, which is only available when `Playing steps` state is active. As a consequence, we need to find another way to store that an error occurred.

The first idiomatic way to solve the issue is to store another property into the context:

```ts {2-12, 17, 21-24, 31-36}
const vizMachine = createMachine({
    // ...
    context: {
        // Other properties...
        hasLastExecutionFailed: false,
    },
    schema: {
        context: {} as {
            // Other properties...
            hasLastExecutionFailed: boolean;
        },
        // ...
    },
    initial: "Playing steps",
    states: {
        "Playing steps": { /** */ },
        "Making request to server": {
            entry: "Reset whether last execution failed",
            invoke: {
                src: "Execute machine and input on server",
                // ...
                onError: {
                    target: "Playing steps",
                    actions: "Set that last execution failed",
                },
            },
        },
    },
    // ...
}, {
    actions: {
        "Reset whether last execution failed": assign({
            hasLastExecutionFailed: (_context) => false,
        }),
        "Set that last execution failed": assign({
            hasLastExecutionFailed: (_context) => true,
        }),
    },
});
```

There is more work to do, as we need to reset the property when making another request, but this works well.

What I dislike with this solution is that request to server is too tightly coupled with visualizer management. If tomorrow we want to allow users to perform some actions while request is pending, we would need to substantially change the machine. This is not to say that in normal circumstances refactoring should be avoided when involving heavy changes, but here the refactoring would be huge because at first we used the wrong tools to solve the problem.

We had a hard time figuring out how to insert request to server in visualizer management flow because these both parts are **interleaved**: they are neither totally independent nor totally mutually exclusive.

There are two tools in XState to implement interleaved behaviors: [parallel states](https://xstate.js.org/docs/guides/parallel.html) and services (especially [machine services](https://xstate.js.org/docs/guides/communication.html#invoking-machines)). Choosing between one or the other really depends on the context of use, but here I think parallel states are more suitable as both behaviors are more coupled than independent, and they would benefit from being written in the same machine.

We refactor the machine to use a parallel state:

```ts
const vizMachine = createMachine({
    // ...
    type: "parallel",
    states: {
        // First orthogonal (independent) region
        "Managing visualizer execution": {
            initial: "Playing steps",
            states: {
                "Playing steps": { /** */ },
                "Reached end of steps": { /** */ },
            },
        },
        // Second orthogonal (independent) region
        "Managing input and machine execution": {
            initial: "Idle",
            states: {
                "Idle": {},
                "Making request to server": {
                    invoke: {
                        src: "Execute machine and input on server",
                        onDone: {
                            actions: "Assign machine execution to context",
                            target: "Received response",
                        },
                        onError: {
                            target: "Failed to execute machine with input",
                        },
                    },
                },
                "Received response": { /** */ },
                "Failed to execute machine with input": { /** */ },
            },
            on: {
                Load: {
                    target: ".Making request to server",
                },
            },
        },
    },
    // ...
});
```

An important feature of parallel states is that all active regions receive events and can handle them separately. Here, `Managing input and machine execution` state goes to its child state `Making request to server` that starts the request.

The previous implementation that did not use parallel states was preventing users from interacting with the visualizer while a request was performing. We must update our latest implementation to behave the same.

First, we disable the visualizer when loading starts, and we ensure visualizer is only available after a machine has been executed:

```ts {5, 7, 11-15}
const vizMachine = createMachine({
    // ...
    type: "parallel",
    states: {
        "Managing visualizer execution": {
            initial: "Idle",
            states: {
                Idle: {},
                "Playing steps": { /** */ },
                "Reached end of steps": { /** */ },
            },
            on: {
                Load: {
                    target: ".Idle",
                },
            },
        },
        "Managing input and machine execution": {
            // ...
            on: {
                Load: { /** */ },
            },
        },
    },
    // ...
});
```

When machine starts or when an execution starts, `Idle` state is entered. Note that `Load` state is caught in both orthogonal regions, and leads to different actions in both regions.

Now we need to enter in `Playing steps` state when Turing machine has been executed successfully:

```ts {3-8, 15-21, 39, 45-47, 56-58}
import { send } from 'xstate';

const vizMachine = createMachine({
    schema: {
        // ...
        events: {} as
            | { type: "..." } // Other events...
            | { type: "Enable playing execution steps" }
    },
    // ...
    type: "parallel",
    states: {
        "Managing visualizer execution": {
            initial: "Idle",
            states: {
                Idle: {
                    on: {
                        "Enable playing execution steps": {
                            target: "Playing steps"
                        },
                    },
                },
                "Playing steps": { /** */ },
                "Reached end of steps": { /** */ },
            },
            on: {
                Load: {
                    target: ".Idle",
                },
            },
        },
        "Managing input and machine execution": {
            initial: "Idle",
            states: {
                "Idle": {},
                "Making request to server": {
                    invoke: {
                        src: "Execute machine and input on server",
                        onDone: {
                            actions: "Assign machine execution to context",
                            target: "Received response",
                        },
                        // ...
                    },
                },
                "Received response": {
                    entry: "Allow to play execution steps",
                },
                "Failed to execute machine with input": { /** */ },
            },
            // ...
        },
    },
    // ...
}, {
    actions: {
        "Allow to play execution steps": send({
            type: "Enable playing execution steps",
        }),
    },
});
```

When execution succeeds, we assign steps to context, and we enter `Received response` state, which sends `Enable playing execution steps` event to the machine itself. Here we rely on a corollary of the fact that all active orthogonal regions of a statechart receive events: they also receive events sent by other orthogonal regions. It's called *broadcasting*. In `Idle` we wait for `Enable playing execution steps` event to go to `Playing steps` state.

We may think that this solution is overengineered and involves a lot more code to achieve the same result. And in a way it's true, we wrote more code. But we wrote more explicit, more robust and less *hacky* code.

If we want to know if error alert should be shown, we can test whether machine is in `Failed to execute machine with input` state, without needing to maintain a boolean in context.

If in a week we want to allow users to interact with visualizer while a request is pending, all we would have to do is removing an event listener:


```ts {17-19}
const vizMachine = createMachine({
    // ...
    type: "parallel",
    states: {
        "Managing visualizer execution": {
            initial: "Idle",
            states: {
                Idle: {
                    on: {
                        "Enable playing execution steps": {
                            target: "Playing steps"
                        },
                    },
                },
                "Playing steps": { /** */ },
                "Reached end of steps": { /** */ },
            },
            on: {
                // No longer going to `Idle` when receiving `Load` event.
            },
        },
        // ...
    },
    // ...
});
```

As a lot of things in development, the best solution is context-dependent. Parallel states are perfect to allow a machine to orchestrate more than one thing at a time, but this can lead to synchronization issues and less understandable code. I talked about this problem in [a YouTube video](https://youtu.be/Lvpi0XM_Nzg).

## Prevent loading animation from flickering when network is fast

Loading indicators are necessary for users to know that they are waiting something that will happen, and not wasting their time. But bad UX comes when loading indicators are directly bound to HTTP responses, that can come really fast, making loading indicator flicker. [Sam Selikoff explains it well in one of his videos](https://youtu.be/YnksFDAN_GA).

The solution is to ensure loading state is always displayed enough time for users to see it, understand something is loading, and do not be surprised by a rough disappearing. Once again, parallel states can help us.

Instead of directly targeting the state that makes the request when receiving a `Load` event, we target a parallel state:

```ts
const vizMachine = createMachine({
    context: {
        // Other properties...
        errorHasOccuredWhileSendingRequest: false,
    },
    schema: {
        context: {} as {
            // Other properties...
            errorHasOccuredWhileSendingRequest: boolean;
        },
    },
    // ...
    type: "parallel",
    states: {
        // ...
        "Managing input and machine execution": {
            initial: "Idle",
            states: {
                "Idle": {},
                "Executing machine and input": {
                    entry: "Reset that error has occured while sending request",
                    // We have a parallel state inside a parallel state!
                    type: "parallel",
                    states: {
                        "Making request to server": {
                            initial: "Sending request",
                            states: {
                                // The state we were using to make
                                // the request behaves the same.
                                "Sending request": {
                                    invoke: {
                                        src: "Execute machine and input on server",
                                        onDone: {
                                            actions: "Assign machine execution to context",
                                            target: "Received response",
                                        },
                                        onError: {
                                            target: "Error occured",
                                        },
                                    },
                                },
                                "Received response": {
                                    type: "final",
                                },
                                "Error occured": {
                                    // Save information to context
                                    // to dissociate final states.
                                    entry:
                                        "Assign error has occured while sending request to context",
                                    type: "final",
                                },
                            },
                        },
                    },
                    // When all orthogonal regions of a parallel state
                    // reach a final state, the parallel state
                    // is considered to be *done*.
                    onDone: [
                        {
                            cond: "Error has occured while sending request",
                            target: "Failed to execute machine with input",
                        },
                        {
                            target: "Received response",
                        },
                    ],
                },
                "Received response": { /** */ },
                "Failed to execute machine with input": { /** */ },
            },
            // ...
        },
    },
    // ...
}, {
    actions: {
        "Assign error has occured while sending request to context":
            assign({
                errorHasOccuredWhileSendingRequest: (_context) => true,
            }),
        "Reset that error has occured while sending request": assign({
          errorHasOccuredWhileSendingRequest: (_context) => false,
        }),
    },
    guards: {
        "Error has occured while sending request": ({
          errorHasOccuredWhileSendingRequest,
        }) => errorHasOccuredWhileSendingRequest === true,
    },
});
```

The machine behaves exactly the same as previously, in a more sophisticated way. We benefit from the fact that when all the orthogonal regions of a parallel state reach a final state, the parallel state is considered to be *done* and `onDone` transitions defined on it are tried.

Currently, `Executing machine and input` only has one orthogonal region (`Making request to server`), that reaches a final state when request returns. If the execution fails, we assign a property to context to be able to later know if the execution failed, once the overall parallel state is done. Think of a parallel state used like this as a `Promise.all` that would not know the resolved value of each promise; values must be assigned somewhere, like so:

```ts
let errorHasOccuredWhileSendingRequest = false;

await Promise.all([
    executeMachineWithInputPromise.catch(() => {
        errorHasOccuredWhileSendingRequest = true;
    }),
]);
```

Once all orthogonal regions are done, `onDone` transitions defined on the parallel state are tried. If `Error has occured while sending request` returns `true`, we target the error state (`Failed to execute machine with input`), otherwise we target the success state (`Received response`). `Failed to execute machine with input` can be used to conditionally display the error alert as it used to!

The last thing to do is to implement a delay of one second:

```ts {14-28}
const vizMachine = createMachine({
    // ...
    type: "parallel",
    states: {
        // ...
        "Managing input and machine execution": {
            initial: "Idle",
            states: {
                "Idle": {},
                "Executing machine and input": {
                    entry: "Reset that error has occured while sending request",
                    type: "parallel",
                    states: {
                        "Making request to server": { /** */ },
                        "Delaying loading state": {
                            initial: "Pending",
                            states: {
                                Pending: {
                                    after: {
                                        "1000": {
                                            target: "Reached end of delay",
                                        },
                                    },
                                },
                                "Reached end of delay": {
                                    type: "final",
                                },
                            },
                        },
                    },
                    onDone: [
                        {
                            cond: "Error has occured while sending request",
                            target: "Failed to execute machine with input",
                        },
                        {
                            target: "Received response",
                        },
                    ],
                },
                "Received response": { /** */ },
                "Failed to execute machine with input": { /** */ },
            },
            // ...
        },
    },
    // ...
});
```

A timer of one second is started, which triggers a transition to a final state after. The behavior of the parallel state is now to wait for its both orthogonal regions to finish.

If the network is fast, we artificially wait for one second:

![Execute machine with a fast network and artificially wait for one second](/img/turing/fast-network.gif)

If the request fails, we display the error alert only after one second:

![Execute machine but request fails, still artificially wait for one second](/img/turing/network-fails.gif)

If the network is slow, but the request takes less than one second, we wait a bit artificially:

![Execute machine with a slow network in less than a second and artificially wait for one second](/img/turing/slow-network-less-1s.gif)

If the network is slow and the request takes more than one second, we do not wait artificially and stop displaying loading indicator when response arrives:

![Execute machine with a slow network in less than a second and artificially wait for one second](/img/turing/slow-network-more-1s.gif)

I recorded [a video about loading state with XState](https://youtu.be/BLyn0CIi0Zw).

## Indicate when input or machine configuration are stale

This is the feature I'm the most proud of, while it's probably one of the simplest to implement. But it gives the visualizer a more professional look.

When input or machine configuration are different from the last input and machine configuration that led to a successful execution, we indicate that inputs are stale:

![Stale indicator is displayed when input and machine configuration change](/img/turing/stale-indicator.gif)

To implement this, first we need to cache the previous input and machine configuration when we receive a successful execution result:

```ts {1-12, 29-32, 48-51}
const vizMachine = createMachine({
    context: {
        // Other properties...
        lastSuccessfullyExecutedInput: undefined,
        lastSuccessfullyExecutedMachineCode: undefined,
    },
    schema: {
        context: {} as {
            // Other properties...
            lastSuccessfullyExecutedInput: string | undefined;
            lastSuccessfullyExecutedMachineCode: string | undefined;
        },
    },
    // ...
    type: "parallel",
    states: {
        // ...
        "Managing input and machine execution": {
            initial: "Idle",
            states: {
                "Idle": {},
                "Executing machine and input": {
                    // ...
                    type: "parallel",
                    states: {
                        "Making request to server": {
                            initial: "Sending request",
                            states: {
                                "Sending request": { /** */ },
                                "Received response": {
                                    entry: "Cache input and machine code into context",
                                    type: "final",
                                },
                                "Error occured": { /** */ },
                            },
                        },
                    },
                    onDone: [ /** */ ],
                },
                "Received response": { /** */ },
                "Failed to execute machine with input": { /** */ },
            },
            // ...
        },
    },
    // ...
}, {
    actions: {
        "Cache input and machine code into context": assign({
            lastSuccessfullyExecutedInput: (context) => context.input,
            lastSuccessfullyExecutedMachineCode: (context) => context.machineCode,
        }),
    },
});
```

Then in Vue side, we create a `computed`:

```ts
import { computed } from 'vue';

const isStale = computed(() => {
    const {
        input,
        lastSuccessfullyExecutedInput,
        machineCode,
        lastSuccessfullyExecutedMachineCode
    } = state.value.context;

    if (
        lastSuccessfullyExecutedInput === undefined ||
        lastSuccessfullyExecutedMachineCode === undefined
    ) {
        return false;
    }

    return (
        input !== lastSuccessfullyExecutedInput ||
        machineCode !== lastSuccessfullyExecutedMachineCode
    );
});
```

If no successful execution has been performed yet, cached values are `undefined` and data are not stale. Otherwise, we compare values with the cached ones.

This is a stylistic detail that improves the UX, and that is not so hard to implement!

## Orchestrate loading button with a frontal machine

![Submit button transitions to loading state and then success state](/img/turing/submit-button-successful-state.gif)

Until now, we assumed that `Load` event, used to trigger execution of machine configuration with input, was sent to `vizMachine` when clicking on the `Load` button.

Indeed, the origin of the event is the user clicking on the button, but there is a step in-between.

```ts
import { sendParent } from "xstate";

const submitButtonMachine = createMachine({
    schema: {
        events: {} as
            | { type: "Load" }
            | { type: "Finished loading" }
            | { type: "Erred" },
    },
    initial: "Idle",
    states: {
        Idle: {
            on: {
                Load: {
                    actions: "Forward button has been clicked to parent",
                    target: "Loading",
                },
            },
        },
        Loading: {
            on: {
                "Finished loading": {
                    target: "Success",
                },
                Erred: {
                    target: "Error",
                },
            },
        },
        Success: {
            after: {
                "2000": {
                    target: "Idle",
                },
            },
        },
        Error: {
            after: {
                "2000": {
                    target: "Idle",
                },
            },
        },
    },
}, {
    actions: {
        "Forward button has been clicked to parent": sendParent({
            type: "Load",
        }),
    },
});
```

We'll see that this machine interacts with its parent machine and expect it to respond.

### Forward `Load` event to parent

When in `Idle` state and receiving a `Load` event, the machine forwards the `Load` event to its parent:

```ts {8-11, 19-21}
import { sendParent } from "xstate";

const submitButtonMachine = createMachine({
    // ...
    initial: "Idle",
    states: {
        Idle: {
            on: {
                Load: {
                    actions: "Forward button has been clicked to parent",
                    target: "Loading",
                },
            },
        },
        Loading: { /** */ },
        // ...
    },
}, {
    actions: {
        "Forward button has been clicked to parent": sendParent({
            type: "Load",
        }),
    },
});
```

But what is its *parent*? When it starts, `vizMachine` invokes `submitButtonMachine` as a long-running service:

```ts
const vizMachine = createMachine({
    // ...
    invoke: {
        src: "Start submit button machine",
        id: "Submit button",
    },
    // ...
}, {
    services: {
        "Start submit button machine": submitButtonMachine,
    },
});
```

As a consequence, in `submitButtonMachine` machine, `sendParent` action can be used to send events to the machine that invoked it.

To summarize, when user clicks on *Load* button, `Load` event is received in `Idle` state and the machine forwards it to its parent, that makes a request to the server.

### Wait for response from parent

The purpose of `submitButtonMachine` is to debounce clicks on *Load* button, and to make transitions take enough time to be pleasant to the user.

`Success` and `Error` states are active for two seconds and then target `Idle` state:

```ts {13-26}
const submitButtonMachine = createMachine({
    // ...
    initial: "Idle",
    states: {
        Idle: {
            on: {
                Load: {
                    actions: "Forward button has been clicked to parent",
                    target: "Loading",
                },
            },
        },
        Loading: { /** */ },
        Success: {
            after: {
                "2000": {
                    target: "Idle",
                },
            },
        },
        Error: {
            after: {
                "2000": {
                    target: "Idle",
                },
            },
        },
    },
});
```

But to know if the request was successful or not, we need to wait for the response from the parent:

```ts {5-14}
const submitButtonMachine = createMachine({
    // ...
    initial: "Idle",
    states: {
        Idle: { /** */ },
        Loading: {
            on: {
                "Finished loading": {
                    target: "Success",
                },
                Erred: {
                    target: "Error",
                },
            },
        },
        Success: { /** */ },
        Error: { /** */ },
    },
});
```

And in parent machine, we send the events expected by `submitButtonMachine` machine when response is received:

```ts {6, 15, 22, 30-47}
import { send } from "xstate";

const vizMachine = createMachine({
    // ...
    invoke: {
        src: "Start submit button machine",
        id: "Submit button",
    },
    // ...
    initial: "Sending request",
    states: {
        "Sending request": { /** */ },
        "Received response": {
            entry: [
                "Cache input and machine code into context",
                "Exit loading state from submit button",
            ],
            type: "final",
        },
        "Error occured": {
            entry: [
                "Assign error has occured while sending request to context",
                "Enter error state from submit button",
            ],
            type: "final",
        },
    },
    // ...
}, {
    actions: {
        "Exit loading state from submit button": send(
            {
                type: "Finished loading",
            },
            {
                // Use id of service
                to: "Submit button",
            }
        ),
        "Enter error state from submit button": send(
            {
                type: "Erred",
            },
            {
                // Use id of service
                to: "Submit button",
            }
        ),
    },
});
```

To send an event to an invoked service, we use the `send` action and provide an option object with `to` property that is the id of the service.

Apart from the fact that events are exchanged between different machines, the base contract remains the same: events are sent and listened to.

This even works good in case of error!

![Submit button transitions to loading state and then failure state](/img/turing/submit-button-failure-state.gif)
