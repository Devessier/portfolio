---
title: Create a Turing machine visualizer with XState and Vue
description: Blog post description
datetime: 2022-07-31T11:56:59.393Z
tags: ['XState', 'Vue']
---

Hi from **Create a Turing machine visualizer with XState and Vue** article!

## Move tape automatically

When the user clicks to play the machine, the tape moves automatically, one frame per second. The speed can be increased to reach two frames per second.

![Tape moves automatically and speed is increased](/img/turing/automatic-playing-with-different-speed-modes.gif)

By default, automatic playing is off. User needs to click the play button to start automatic playing.

```ts
import { createMachine } from "xstate";

const vizMachine = createMachine({
    // ...
    initial: "Automatic playing off",
    states: {
        "Automatic playing off": {
            on: {
                Play: {
                    target: "Automatic playing on",
                },
            },
        },
        "Automatic playing on": {},
    },
    // ...
});
```

To make automatic playing work, we create a delayed transition in `Automatic playing on` state, that transitions to the state itself, after incrementing the index of the step.

```ts {1-8, 21-26, 32-36}
const vizMachine = createMachine({
    context: {
        stepsIndex: 0,
    },
    schema: {
        context: {} as {
            stepsIndex: number;
        },
    },
    // ...
    initial: "Automatic playing off",
    states: {
        "Automatic playing off": {
            on: {
                Play: {
                    target: "Automatic playing on",
                },
            },
        },
        "Automatic playing on": {
            after: {
                "automatic playing delay": {
                    actions: "Increment step index",
                    target: "Automatic playing on",
                    // Make the transition external to recreate the delay.
                    internal: false,
                },
            },
        },
    },
    // ...
}, {
    actions: {
        "Increment step index": assign({
            stepIndex: (context) => context.stepIndex + 1,
        }),
    },
});
```

Note that the transition is explicitly made external through `internal: false`. This is necessary because the state needs to be reentered for the delayed transition to be set up again.

The delay is defined with a string, which references a function dynamically computing the delay. It uses the speed mode, stored in context, to determine the delay between two frames:

```ts {1-14, 31-35, 38-42, 47-49}
const vizMachine = createMachine({
    context: {
        stepsIndex: 0,
        automaticPlayingDelayMode: "MEDIUM",
    },
    schema: {
        context: {} as {
            stepsIndex: number;
            automaticPlayingDelayMode: "MEDIUM" | "FAST";
        },
        events: {} as {
            type: "Set automatic playing delay";
            mode: "MEDIUM" | "FAST";
        },
    },
    // ...
    initial: "Automatic playing off",
    states: {
        "Automatic playing off": {
            // ...
        },
        "Automatic playing on": {
            after: {
                "automatic playing delay": {
                    actions: "Increment step index",
                    target: "Automatic playing on",
                    internal: false,
                },
            },
        },
    },
    on: {
        "Set automatic playing delay": {
            actions: "Assign automatic playing delay to context",
        },
    },
    // ...
}, {
    delays: {
        "automatic playing delay": (context) => {
            return context.automaticPlayingDelayMode === "MEDIUM" ? 1000 : 500
        },
    },
    actions: {
        "Increment step index": assign({
            stepIndex: (context) => context.stepIndex + 1,
        }),
        "Assign automatic playing delay to context": assign({
            automaticPlayingDelayMode: (_, event) => event.mode,
        }),
    },
});
```

If the speed mode is modified, only the timer of the next tick will know about the change. The current timer is not reset.

In Vue side, we compute the squares to print on the tape according to the step list and the current step index, and we let `<TransitionGroup />` handle the smooth transition of squares:

```svelte
<template>
    <TransitionGroup
        move-class="transition-all duration-200"
    >
        <div
            v-for="{ key, value } in displayedTape"
            :id="key"
            :key="key"
        >
            <!-- ... -->
        </div>
    </TransitionGroup>
<template>
```

## Pause and resume automatic playing

![Player is paused and resumed](/img/turing/pause-and-play.gif)

Player can be stopped and resumed with a single state transition:

```ts
const vizMachine = createMachine({
    // ...
    initial: "Automatic playing off",
    states: {
        "Automatic playing off": {
            on: {
                Play: {
                    target: "Automatic playing on",
                },
            },
        },
        "Automatic playing on": {
            after: {
                "automatic playing delay": { /** */ },
            },
            on: {
                Pause: {
                    target: "Automatic playing off",
                },
            },
        },
    },
    // ...
});
```

When we exit `Automatic playing on` state, the delay transition is cancelled. When we come back to `Automatic playing on` state, the delay transition is set up again, and some milliseconds later the tape will have been moved.

## Move tape step by step

When debugging a Turing machine, one would want to analyze what occurs precisely on the tape. In this case, the automatic playing mode would not be really suitable. Instead, the user can move the tape step by step.

![Player is played, then manual mode is entered to execute step by step](/img/turing/manual-step-by-step.gif)

When we receive `Next step` event, that is emitted by next step button, we target `Automatic playing off` state from its parent node. Whether the automatic playing was on or not, we turn it off. We reuse the action that increments the step index and execute it each time the button is clicked:

```ts
const vizMachine = createMachine({
    // ...
    initial: "Automatic playing off",
    states: {
        "Automatic playing off": { /** */ },
        "Automatic playing on": { /** */ },
    },
    on: {
        "Next step": {
            actions: "Increment step index",
            target: ".Automatic playing off",
        },
    },
    // ...
});
```

Again, because `Automatic playing on` state is exited, if a timer was scheduled, it is cancelled.

## Know when end of steps is reached

When end of steps is reached, we want to tell it to user, stop automatic playing and allow restarting steps.

![End of steps is reached and steps are restarted from beginning](/img/turing/reaching-end-of-steps.gif)

To implement this behavior, we need to wrap `Automatic playing off` and `Automatic playing on` states in another state, we name `Playing steps`. This state has a sibling state called `Reached end of steps` we want to target when end of steps has been reached:

```ts
const vizMachine = createMachine({
    // ...
    initial: "Playing steps",
    states: {
        "Playing steps": {
            // States defined previously
            initial: "Automatic playing off",
            states: {
                "Automatic playing off": { /** */ },
                "Automatic playing on": { /** */ },
            },
            on: {
                "Next step": { /** */ },
            },
        },
        "Reached end of steps": {},
    },
    // ...
});
```

We use an eventless transition (with `always` keyword) to target `Reached end of steps` state when `Has reached end of steps` condition is met:

```ts {10-13, 23-30}
const vizMachine = createMachine({
    // ...
    initial: "Playing steps",
    states: {
        "Playing steps": {
            initial: "Automatic playing off",
            states: {
                "Automatic playing off": { /** */ },
                "Automatic playing on": { /** */ },
            },
            always: {
                cond: "Has reached end of steps",
                target: "Reached end of steps",
            },
            on: {
                "Next step": { /** */ },
            },
        },
        "Reached end of steps": {},
    },
    // ...
}, {
    guards: {
        /**
         * The guard must return true after index
         * has been incremented one extraneous time.
         * There is no step at index `context.stepIndex`.
         */
        "Has reached end of steps": (context) => {
            return context.stepIndex >= STEPS_LENGTH;
        },
    },
});
```

Say that automatic playing is turned on, and the current step is the last one. The behavior of the machine is:

1. Delay is reached
1. Step index is incremented
1. Reenter `Automatic playing on` state
1. Compute `Has reached end of steps` condition; as it returns true, we target `Reached end of steps` state
1. Enter `Reached end of steps` state

`Reached end of steps` state is entered even before the timer of `Automatic playing on` state is restarted.

The eventless transition will be tried when the state in which it is defined is entered for the first time, and then every time something happens in the machine. It includes when an event is received from the outside (from Vue components in our case), but the eventless transition will be tried **after** a transition (including a self-transition) is taken.

### Restart steps when end has been reached

To enable to restart steps, we listen to another event in `Reached end of steps`:

```ts {7-14, 19-21}
const vizMachine = createMachine({
    // ...
    initial: "Playing steps",
    states: {
        "Playing steps": {
            // ...
        },
        "Reached end of steps": {
            on: {
                "Reset steps": {
                    actions: "Reset step index",
                    target: "Playing steps",
                },
            },
        },
    },
    // ...
}, {
    actions: {
        "Reset step index": assign({
            stepIndex: (_context) => 0,
        }),
    }
});
```

When this transition is taken, the tape recovers its original state, and all that remains is for the user to click on play button.
