---
title: Create a proxy state machine to drive CSS transitions on state changes with XState
description: Blog post description
datetime: 2022-08-02T17:26:11.291Z
tags: ['Turing visualizer', 'XState', 'Vue']
---

## Orchestrate loading button with a frontal machine

![Submit button transitions to loading state and then success state](/img/turing/submit-button-successful-state.gif)

Until now, we assumed that `Load` event, used to trigger execution of machine configuration with input, was sent to `vizMachine` when clicking on the `Load` button.

Indeed, the origin of the event is the user clicking on the button, but there is a step in-between: `submitButtonMachine`.

```ts
import { sendParent } from "xstate";

const submitButtonMachine = createMachine({
    schema: {
        events: {} as
            | { type: "Load" }
            | { type: "Finished loading" }
            | { type: "Erred" },
    },
    initial: "Idle",
    states: {
        Idle: {
            on: {
                Load: {
                    actions: "Forward button has been clicked to parent",
                    target: "Loading",
                },
            },
        },
        Loading: {
            on: {
                "Finished loading": {
                    target: "Success",
                },
                Erred: {
                    target: "Error",
                },
            },
        },
        Success: {
            after: {
                "2000": {
                    target: "Idle",
                },
            },
        },
        Error: {
            after: {
                "2000": {
                    target: "Idle",
                },
            },
        },
    },
}, {
    actions: {
        "Forward button has been clicked to parent": sendParent({
            type: "Load",
        }),
    },
});
```

This machine interacts with its parent machine and expects it to respond.

### Forward `Load` event to parent

When in `Idle` state and receiving a `Load` event, the machine forwards the `Load` event to its parent:

```ts {8-11, 19-21}
import { sendParent } from "xstate";

const submitButtonMachine = createMachine({
    // ...
    initial: "Idle",
    states: {
        Idle: {
            on: {
                Load: {
                    actions: "Forward button has been clicked to parent",
                    target: "Loading",
                },
            },
        },
        Loading: { /** */ },
        // ...
    },
}, {
    actions: {
        "Forward button has been clicked to parent": sendParent({
            type: "Load",
        }),
    },
});
```

But what is its *parent*? When it starts, `vizMachine` invokes `submitButtonMachine` as a long-running service:

```ts
const vizMachine = createMachine({
    // ...
    invoke: {
        src: "Start submit button machine",
        id: "Submit button",
    },
    // ...
}, {
    services: {
        "Start submit button machine": submitButtonMachine,
    },
});
```

As a consequence, in `submitButtonMachine` machine, `sendParent` action can be used to send events to the machine that invoked it.

To summarize, when user clicks on *Load* button, `Load` event is received in `Idle` state and the machine forwards it to its parent, that makes a request to the server.

### Wait for response from parent

The purpose of `submitButtonMachine` is to debounce clicks on *Load* button, and to make transitions take enough time to be pleasant to the user.

`Success` and `Error` states are active for two seconds and then target `Idle` state:

```ts {13-26}
const submitButtonMachine = createMachine({
    // ...
    initial: "Idle",
    states: {
        Idle: {
            on: {
                Load: {
                    actions: "Forward button has been clicked to parent",
                    target: "Loading",
                },
            },
        },
        Loading: { /** */ },
        Success: {
            after: {
                "2000": {
                    target: "Idle",
                },
            },
        },
        Error: {
            after: {
                "2000": {
                    target: "Idle",
                },
            },
        },
    },
});
```

But to know if the request was successful or not, we need to wait for the response from the parent:

```ts {5-14}
const submitButtonMachine = createMachine({
    // ...
    initial: "Idle",
    states: {
        Idle: { /** */ },
        Loading: {
            on: {
                "Finished loading": {
                    target: "Success",
                },
                Erred: {
                    target: "Error",
                },
            },
        },
        Success: { /** */ },
        Error: { /** */ },
    },
});
```

So, in parent machine, we send the events expected by `submitButtonMachine` machine when response is received:

```ts {6, 15, 22, 30-47}
import { send } from "xstate";

const vizMachine = createMachine({
    // ...
    invoke: {
        src: "Start submit button machine",
        id: "Submit button",
    },
    // ...
    initial: "Sending request",
    states: {
        "Sending request": { /** */ },
        "Received response": {
            entry: [
                "Cache input and machine code into context",
                "Exit loading state from submit button",
            ],
            type: "final",
        },
        "Error occured": {
            entry: [
                "Assign error has occured while sending request to context",
                "Enter error state from submit button",
            ],
            type: "final",
        },
    },
    // ...
}, {
    actions: {
        "Exit loading state from submit button": send(
            {
                type: "Finished loading",
            },
            {
                // Use id of service
                to: "Submit button",
            }
        ),
        "Enter error state from submit button": send(
            {
                type: "Erred",
            },
            {
                // Use id of service
                to: "Submit button",
            }
        ),
    },
});
```

To send an event to an invoked service, we use the `send` action and provide an option object with `to` property that is the identifier of the service.

Apart from the fact that events are exchanged between different machines, the base contract remains the same: events are sent and listened to.

This even works in case of error!

![Submit button transitions to loading state and then failure state](/img/turing/submit-button-failure-state.gif)
